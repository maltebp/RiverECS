
DESIGN CHOICES


    - ComponentController has to inherit from a base class, since we can't store templated classes in array. This means we also have
        common virtual functions.
    - New components won't be iterated until next domain flush, but can be accessed via the Entity it was assigned
    - Destroyed entities and components will be valid throughout the current cycle, EVEN if they were created in that cycle 


    - Signature Query Caching:
        Removing an entity will invalidate all caches. This is quite a heavy toll?



ENTITY SIGNATURE ALGORITHM
Use a customized bitset-datastructure. This is an array of bitsets with an element for each Entity in the domain. The bitsets has a bit for each possible component in the Domain.

When checking which Entities matches a signature, the array is traversed, by checking each Entity's bitset against the signature bitset.


COMPONENT STORAGE / SEARCH

    Each type of components is stored in a seperate list. At all times, the components in a list are packed (no gaps between elements).

    Mapping Entity to components
        An unordered map, maps the Entity id (Entity*) to component index, and another maps the Component ID to the Entity.

    When a component is deleted, the last component is moved into the element's spot, and the Entity-Index-maps are updated.
